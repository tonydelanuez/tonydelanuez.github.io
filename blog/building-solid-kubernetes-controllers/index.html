<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building Solid Kubernetes Controllers | tdoot's odd little bazaar</title><meta name=keywords content="kubernetes"><meta name=description content="In the last post, I explained the utility and purpose of Kubernetes Controllers. This post will explain how to build them, and how to think about designing them. We&rsquo;ll go into Controller patterns, anti-patterns, and sharp edges of the model that you&rsquo;re bound to run into.
controller-runtime - use it. Or don&rsquo;t, I don&rsquo;t care. It&rsquo;ll probably help though.
You can absolutely build a controller from scratch using client-go (and sometimes that makes sense), but most of the time you should just get started with controller-runtime."><meta name=author content="Tony"><link rel=canonical href=https://tdoot.com/blog/building-solid-kubernetes-controllers/><link crossorigin=anonymous href=/assets/css/stylesheet.4476293b724263f604c7d28f33ec2ff3f76e730dfb1de39f57caeadd5b4533b8.css integrity="sha256-RHYpO3JCY/YEx9KPM+wv8/ducw37HeOfV8rq3VtFM7g=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://tdoot.com/images/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tdoot.com/images/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tdoot.com/images/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://tdoot.com/images/icons/apple-touch-icon.png><link rel=mask-icon href=https://tdoot.com/images/icons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y62CJP0177"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y62CJP0177",{anonymize_ip:!1})}</script><meta property="og:title" content="Building Solid Kubernetes Controllers"><meta property="og:description" content="In the last post, I explained the utility and purpose of Kubernetes Controllers. This post will explain how to build them, and how to think about designing them. We&rsquo;ll go into Controller patterns, anti-patterns, and sharp edges of the model that you&rsquo;re bound to run into.
controller-runtime - use it. Or don&rsquo;t, I don&rsquo;t care. It&rsquo;ll probably help though.
You can absolutely build a controller from scratch using client-go (and sometimes that makes sense), but most of the time you should just get started with controller-runtime."><meta property="og:type" content="article"><meta property="og:url" content="https://tdoot.com/blog/building-solid-kubernetes-controllers/"><meta property="og:image" content="https://tdoot.com/images/pictures/portrait.jpg"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-12-13T17:50:05-06:00"><meta property="article:modified_time" content="2024-12-13T17:50:05-06:00"><meta property="og:site_name" content="tdoot's odd little bazaar"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tdoot.com/images/pictures/portrait.jpg"><meta name=twitter:title content="Building Solid Kubernetes Controllers"><meta name=twitter:description content="In the last post, I explained the utility and purpose of Kubernetes Controllers. This post will explain how to build them, and how to think about designing them. We&rsquo;ll go into Controller patterns, anti-patterns, and sharp edges of the model that you&rsquo;re bound to run into.
controller-runtime - use it. Or don&rsquo;t, I don&rsquo;t care. It&rsquo;ll probably help though.
You can absolutely build a controller from scratch using client-go (and sometimes that makes sense), but most of the time you should just get started with controller-runtime."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"","item":"https://tdoot.com/blog/"},{"@type":"ListItem","position":2,"name":"Building Solid Kubernetes Controllers","item":"https://tdoot.com/blog/building-solid-kubernetes-controllers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building Solid Kubernetes Controllers","name":"Building Solid Kubernetes Controllers","description":"In the last post, I explained the utility and purpose of Kubernetes Controllers. This post will explain how to build them, and how to think about designing them. We\u0026rsquo;ll go into Controller patterns, anti-patterns, and sharp edges of the model that you\u0026rsquo;re bound to run into.\ncontroller-runtime - use it. Or don\u0026rsquo;t, I don\u0026rsquo;t care. It\u0026rsquo;ll probably help though.\nYou can absolutely build a controller from scratch using client-go (and sometimes that makes sense), but most of the time you should just get started with controller-runtime.","keywords":["kubernetes"],"articleBody":"In the last post, I explained the utility and purpose of Kubernetes Controllers. This post will explain how to build them, and how to think about designing them. We’ll go into Controller patterns, anti-patterns, and sharp edges of the model that you’re bound to run into.\ncontroller-runtime - use it. Or don’t, I don’t care. It’ll probably help though.\nYou can absolutely build a controller from scratch using client-go (and sometimes that makes sense), but most of the time you should just get started with controller-runtime. It provides a batteries-included approach to handling typical Kubernetes controller patterns and gives you everything you need when it comes to things like leader election (you want HA, right?), metrics \u0026 events, caching, and even webhook setup and serving. When you just need to watch some resources and have your controller reconcile some state when the resource changes, controller-runtime is awesome.\nIf you need super fine-grained control over the watching behavior or caching (for perf or scaling reasons or otherwise), you’ll probably find yourself poking too many holes through the Watch/Owns abstraction and should consider something a bit more bespoke.\nAdditionally, if you have extremely complex state machine transitions or want to take actions against different kinds of updates (create/delete/update) against your resources, the standard .Reconcile(object) approach that controller-runtime gives you may leave you fighting against the framework.\nHere’s an extremely simple example controller implementation from their examples:\n// reconcileReplicaSet reconciles ReplicaSets type reconcileReplicaSet struct { // client can be used to retrieve objects from the APIServer. client client.Client } // Implement reconcile.Reconciler so the controller can reconcile objects var _ reconcile.Reconciler = \u0026reconcileReplicaSet{} func (r *reconcileReplicaSet) Reconcile(ctx context.Context, request reconcile.Request) (reconcile.Result, error) { // set up a convenient log object so we don't have to type request over and over again log := log.FromContext(ctx) // Fetch the ReplicaSet from the cache rs := \u0026appsv1.ReplicaSet{} err := r.client.Get(ctx, request.NamespacedName, rs) if errors.IsNotFound(err) { log.Error(nil, \"Could not find ReplicaSet\") return reconcile.Result{}, nil } if err != nil { return reconcile.Result{}, fmt.Errorf(\"could not fetch ReplicaSet: %+v\", err) } // Print the ReplicaSet log.Info(\"Reconciling ReplicaSet\", \"container name\", rs.Spec.Template.Spec.Containers[0].Name) // Set the label if it is missing if rs.Labels == nil { rs.Labels = map[string]string{} } if rs.Labels[\"hello\"] == \"world\" { return reconcile.Result{}, nil } // Update the ReplicaSet rs.Labels[\"hello\"] = \"world\" err = r.client.Update(ctx, rs) if err != nil { return reconcile.Result{}, fmt.Errorf(\"could not write ReplicaSet: %+v\", err) } return reconcile.Result{}, nil } read the sacred texts Before you dive into building your own controllers though, do yourself a favor and spend some quality time with the Kubebuilder book (https://book.kubebuilder.io/). Understanding how Kubernetes expects APIs to behave will save you countless hours of headaches down the road. It’ll also set you up well for writing CRDs and generating their specs from go types.\nSecond, SIG Architecture has laid out some seriously well-thought-out conventions in their API guidelines. I constantly find myself referring to these guidelines, especially for things like exposing meaningful statuses and conditions. These aren’t just suggestions - they’re the difference between your controller playing nice with the ecosystem and it being that one weird implementation that makes everyone’s lives harder. Take it from someone who’s had to refactor controllers because they didn’t align with these patterns: invest the time upfront to understand how status conditions should work, what fields belong in spec versus status, and how to structure your CRDs properly.\nFollowing these conventions will make sure your controller behaves how users expect it to. While your controller can be “technically correct” or “built to spec”, it’s a lot better of an experience for users when it has clear side effects, integrates well with existing tooling, and provides meaningful information about what its doing.\nlevel-triggered vs. edge-triggered design Let’s talk about one of the most important design principles in Kubernetes controllers: level-triggered behavior. If you’re coming from a background in systems programming, you might be familiar with these terms from event notification systems like epoll. If not, don’t worry - I’ll break it down.\nEdge-triggered systems react to changes (the “edges” between states). Think of it like a motion sensor light - it only triggers when it detects movement. Level-triggered systems, on the other hand, continuously check the current state against the desired state. This is more like the thermostat example from the last blog (and k8s docs) that’s constantly checking if the room temperature matches what you’ve set.\nKubernetes controllers are designed to be level-triggered, and this is absolutely crucial. Here’s why:\n// Edge-triggered (swat! bad, no!) func (r *Reconciler) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) { var myResource myv1.MyResource if err := r.client.Get(ctx, req.NamespacedName, \u0026myResource); err != nil { return reconcile.Result{}, err } // Only react to specific changes if myResource.Generation != myResource.Status.ObservedGeneration { // Handle the change return r.handleSpecChange(\u0026myResource) } // Otherwise do nothing return reconcile.Result{}, nil } // Level-triggered (yes... good, good) func (r *Reconciler) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) { var myResource myv1.MyResource if err := r.client.Get(ctx, req.NamespacedName, \u0026myResource); err != nil { return reconcile.Result{}, err } // Always check everything current := r.gatherCurrentState(ctx, \u0026myResource) desired := r.calculateDesiredState(\u0026myResource) // Make any needed changes to align current with desired return r.reconcileState(ctx, \u0026myResource, current, desired) } The edge-triggered approach might seem more efficient at first glance. Why do work if nothing’s changed, right? But this thinking can lead to some nasty failure modes:\nWhat if your controller crashes while processing a change? Without checking the full state each time, you might miss that the work wasn’t completed.\nWhat if an external agent (like an angry engineer just trying to get their thing to work with kubectl) modifies a resource your controller manages? If you’re only watching for specific changes, you might miss these modifications entirely.\nWhat if the Watch connection to the API server hiccups and you miss some events (more on this later)? With an edge-triggered approach, you’re now out of sync and might not catch up.\nA level-triggered approach means our controller is resilient to all sorts of failures - missed events, external changes, partial failures during reconciliation, you name it. Each reconciliation loop is a fresh chance to make things right.\nThe Watch API is still important - it’s how we know when to check things quickly rather than waiting for our periodic reconciliation. But we never assume that the watch events tell us everything we need to know about what’s changed. They’re more like helpful hints about when to look, not authoritative statements about what’s different.\nThis pattern of “calculate desired state, check current state, fix differences” is fundamental to how Kubernetes itself works. It’s what makes the system so resilient to failures and so good at self-healing. When you’re building your own controllers, embrace this pattern. Your future self (and your on-call rotation) will thank you.\nbreaking down the reconciliation loop Now let’s assume you’ve taken my advice, are using controller-runtime, did the recommended reading, and understand level-triggered design. You’ve gotten setup out of the way and now need to build your functionality into the controller.\nAs you saw above, with controller-runtime you’re given an entrypoint in the Reconcile method. This is kicked off by the Watch API, which gives you a stream of events for resources you care about (you can do all objects of kind X, only those matching certain labels, up to you). An important callout here is that you can’t trust that you’ll see every event. Watches can disconnect, events can be missed, and sometimes the API server may just kick your watch and restart it. This is what makes the reconciliation loop so important. You’re not just handling events as they come in - you’re responsible for ensuring the entire state is correct every time you reconcile the resource.\nHere’s how you should think about reconciliation:\nfunc (r *Reconciler) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) { log := log.FromContext(ctx) // 1. Get your resource. var myResource myv1.MyResource if err := r.client.Get(ctx, req.NamespacedName, \u0026myResource); err != nil { return r.handleGetError(err) } // 2. Check if we're deleted/being deleted if !myResource.DeletionTimestamp.IsZero() { if controllerutil.ContainsFinalizer(\u0026myResource, myFinalizerName) { // Run any necessary cleanup logic. if err := r.cleanupExternalResources(ctx, \u0026myResource); err != nil { return reconcile.Result{}, fmt.Errorf(\"cleanup failed: %w\", err) } } // Remove our finalizer to allow deletion to continue. controllerutil.RemoveFinalizer(\u0026myResource, myFinalizerName) if err := r.client.Update(ctx, \u0026myResource); err != nil { return reconcile.Result{}, fmt.Errorf(\"finalizer removal failed: %w\", err) } // Thing's been deleted, nothing to do. // (Or you can add additional logic here) return reconcile.Result{}, nil } // 3. Ensure our finalizer is present for active resources. if err := r.ensureFinalizer(ctx, \u0026myResource); err != nil { return reconcile.Result{}, fmt.Errorf(\"ensuring finalizer failed: %w\", err) } // 4. Validate current state. if err := r.validateResource(\u0026myResource); err != nil { return r.handleValidationError(ctx, \u0026myResource, err) } // 5. Check dependent resources if your resource manages other resources. dependentResources, err := r.gatherDependentResources(ctx, \u0026myResource) if err != nil { return reconcile.Result{}, fmt.Errorf(\"gathering dependent resources failed: %w\", err) } // 6. Determine what needs to change. changes := r.determineRequiredChanges(\u0026myResource, dependentResources) // 7. Apply changes. if err := r.applyChanges(ctx, \u0026myResource, changes); err != nil { return r.handleChangeError(ctx, err) } // 8. Update status. if err := r.updateStatus(ctx, \u0026myResource, dependentResources); err != nil { return reconcile.Result{}, fmt.Errorf(\"updating status failed: %w\", err) } // 9. Schedule next reconciliation if needed. return r.determineNextReconcile(\u0026myResource) } There’s a lot to unpack here, let’s go through it.\nresource ownership One of the most fundamental patterns in Kubernetes controllers is resource ownership. When your controller creates resources on behalf of your custom resource (like ConfigMaps, Secrets, or even Pods), you need to establish proper ownership relationships. This isn’t just about being organized - it’s about enabling Kubernetes’ garbage collection to work properly.\nIf your resource creates ConfigMaps for example, you’ll end up setting ControllerReferences:\nfunc (r *Reconciler) createConfigMap(ctx context.Context, owner *myv1.MyResource, name string, data map[string]string) error { configMap := \u0026corev1.ConfigMap{ ObjectMeta: metav1.ObjectMeta{ Name: name, Namespace: owner.Namespace, }, Data: data, } // This is crucial - it sets up the owner reference. if err := controllerutil.SetControllerReference(owner, configMap, r.scheme); err != nil { return fmt.Errorf(\"setting controller reference: %w\", err) } // Create with a retry in case of conflicts. return retry.RetryOnConflict(retry.DefaultRetry, func() error { err := r.client.Create(ctx, configMap) if err != nil \u0026\u0026 !apierrors.IsAlreadyExists(err) { return err } return nil }) } Now you’ve set up a relationship where MyResource --owns--\u003e ConfigMap. Make sure you’re thinking through what could happen with the lifecycle of these resources:\nWhat happens if a child resource is manually deleted? If you expect it to always be there you may introduce a panic. What order should resources be created in? This was important when I worked on something that replicated Helm. How do you handle partial creation scenarios? If some of your resources get created but others fail, do you have to tear-down and retry? When managing dependent resources, you should consider collecting failures and surfacing them as reconciliation failures via your owner resources’ Conditions so downstream users can see the failures. Logs may be great for you, but Kubernetes Events and Conditions are great for you AND your users :)\nThat brings me to my next point.\nstate tracking and status updates Status updates are how your controller communicates with the outside world. They’re not just about setting a “Ready” condition - they’re about providing meaningful information about the state of your resource and its dependencies. Note: PLEASE take the advice of the api-guidelines from the SIG and DO NOT EXPOSE YOUR NOTION OF AN FSM though an Enum. It’s oftentimes more confusing than it is helpful.\nFor an example Resource that manages the deployment of a workload, consider condition Types like the following:\n// Better condition types that follow API conventions const ( // ConditionTypeResourcesAvailable indicates whether all required dependent resources // exist and are functioning correctly. ConditionTypeResourcesAvailable string = \"ResourcesAvailable\" // ConditionTypeConfigurationReady indicates whether the resource's configuration has been // applied successfully. ConditionTypeConfigurationReady string = \"ConfigurationReady\" // ConditionTypeWorkloadHealthy indicates whether the managed workload is operating within // expected parameters ConditionTypeWorkloadHealthy string = \"WorkloadHealthy\" // ConditionTypeReady summarizes the overall operational status of the resource. ConditionTypeReady string = \"Ready\" ) With these conditions (combined with explanatory reasons + messages), users would be well-informed of the status of dependent resources, the workload, and the manager object itself. The condition types have observable states, clear polarity, and include a summary condition that attempts provides a good rollup of any failures.\nresource version handling - conflict resolution Every Kubernetes object has a resource version, and it changes every time the object is modified. This is crucial for implementing optimistic concurrency control. When you update a resource, make sure you pull the latest version of the resource and apply your changes WITHIN the retry.RetryOnConflict function.\nHere’s an example:\nfunc (r *Reconciler) updateResource(ctx context.Context, resource *myv1.MyResource, update func(*myv1.MyResource)) error { return retry.RetryOnConflict(retry.DefaultRetry, func() error { // Get the latest version. fresh := \u0026myv1.MyResource{} if err := r.client.Get(ctx, client.ObjectKeyFromObject(resource), fresh); err != nil { return fmt.Errorf(\"getting fresh resource failed: %w\", err) } // Apply our changes to the fresh copy. update(fresh) // Try to update. if err := r.client.Update(ctx, fresh); err != nil { return err } // Update our local copy if needed. *resource = *fresh return nil }) } finalizers - wake me up before you go go Finalizers are one of those Kubernetes features that seem simple at first glance but have some fascinating complexity under the hood. They’re like the close door button in an elevator - they don’t make the deletion happen faster, but they ensure it happens safely.\nWhen you add a finalizer to a resource, you’re essentially telling Kubernetes “hold up, don’t delete this yet - I need to clean some things up first.” This is crucial when your controller manages resources that exist outside the Kubernetes cluster (like cloud resources) or when you need to ensure proper cleanup of dependent resources.\nHere’s how the deletion process actually works:\nA user or system requests deletion of a resource Kubernetes checks for finalizers If finalizers exist: Sets deletion timestamp Keeps resource around in “terminating” state Controllers see deletion timestamp, perform cleanup Controllers remove their finalizers Once all finalizers are gone, Kubernetes deletes the resource (If you’ve ever tried to delete a namespace and it gets stuck, you’re probably running into a finalizer issue)\nLet’s look at a sample finalizer implementation:\nconst finalizerName = \"awesomecontroller.tdoot.com/cleanup\" func (r *Reconciler) ensureFinalizer(ctx context.Context, resource *myv1.MyResource) error { if !controllerutil.ContainsFinalizer(resource, finalizerName) { controllerutil.AddFinalizer(resource, finalizerName) return r.client.Update(ctx, resource) } return nil } func (r *Reconciler) handleDeletion(ctx context.Context, resource *myv1.MyResource) (reconcile.Result, error) { if !controllerutil.ContainsFinalizer(resource, finalizerName) { return reconcile.Result{}, nil } // Clean up external resources. if err := r.cleanupExternalResources(ctx, resource); err != nil { // If cleanup fails, we keep the finalizer and retry return reconcile.Result{RequeueAfter: time.Minute}, fmt.Errorf(\"cleanup failed: %w\", err) } // Remove our finalizer. controllerutil.RemoveFinalizer(resource, finalizerName) if err := r.client.Update(ctx, resource); err != nil { return reconcile.Result{}, fmt.Errorf(\"removing finalizer failed: %w\", err) } return reconcile.Result{}, nil } rate limiting - cool off Rate limiting in controllers is more complex than just adding some simple delays. We need to handle multiple types of rate limiting:\nWorkqueue rate limiting for individual resources Overall controller throughput API server request limiting External API rate limiting Number 3 brings up a not-so-fond memory of working with a very popular CD tool with a less mature Kubernetes API gateway. It generated so many requests against the API server that we’d effectively lock ourselves out of deploying anything when we hit rate limits. Our deployments would break and because of the rate limits we couldn’t even fix them.\nWhen you look to implement rate-limiting in your controller, check out workqueue.RateLimiter from the client-go package. Here’s an example in their codebase.\ndeep copy - don’t double dip the chip Deep copying in controllers is about more than just avoiding mutations - it’s about handling concurrent access to objects correctly. The client-go cache is shared across all controllers, so we need to be extremely careful about modifications.\nfunc (r *Reconciler) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) { // Get from API server var original myv1.MyResource if err := r.client.Get(ctx, req.NamespacedName, \u0026original); err != nil { return reconcile.Result{}, client.IgnoreNotFound(err) } // ALWAYS work with a copy for modifications. resource := original.DeepCopy() // Do whatever ... // Fetch a fresh copy when you try to apply. return retry.RetryOnConflict(retry.DefaultRetry, func() error { // Get latest version var latest myv1.MyResource if err := r.client.Get(ctx, req.NamespacedName, \u0026latest); err != nil { return err } // Apply our changes to the fresh copy latest.Spec = resource.Spec // Try to update return r.client.Update(ctx, \u0026latest) }) } This attention to copying isn’t just about correctness - it’s about preventing subtle bugs that only show up under load or in production environments. The extra allocations from copying are almost always worth it compared to the cost of debugging race conditions or cache corruption.\nwrapping it all up - build with the pager in mind A properly built controller needs to be resilient to network issues, API server restarts, and engineers who use kubectl edit where they shouldn’t.\nFor your own sake, remember to:\nAlways think level-triggered, not edge-triggered. Your controller should be able to jump in at any point and figure out what needs to be done. Treat the API server’s watch events as helpful hints, not as the single source of truth. Always verify the current state before making changes. Use finalizers religiously, but make sure to not hang! They’re your safety net for cleaning up resources, especially anything outside the cluster. Handle rate limiting at multiple levels. Your controller isn’t the only thing running in the cluster, so play nice with others. Copy objects like your production stability depends on it (because it does). Status conditions aren’t just for show - they’re how your controller communicates with the rest of the world. Most importantly, remember that controllers are part of the control plane of your cluster. They need to be more reliable than the workloads they’re managing. Every panic is a potential outage, every race condition is a ticking time bomb, and every unhandled edge case is a future incident waiting to happen.\n","wordCount":"3018","inLanguage":"en","datePublished":"2024-12-13T17:50:05-06:00","dateModified":"2024-12-13T17:50:05-06:00","author":{"@type":"Person","name":"Tony"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tdoot.com/blog/building-solid-kubernetes-controllers/"},"publisher":{"@type":"Organization","name":"tdoot's odd little bazaar","logo":{"@type":"ImageObject","url":"https://tdoot.com/images/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tdoot.com/ accesskey=h title="Home (Alt + H)"><img src=https://tdoot.com/images/icons/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tdoot.com/categories/blog title=blog><span>blog</span></a></li><li><a href=https://tdoot.com/photos title=photos><span>photos</span></a></li><li><a href=https://tdoot.com/thoughts/ title=thoughts><span>thoughts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tdoot.com/>Home</a>&nbsp;»&nbsp;<a href=https://tdoot.com/blog/></a></div><h1 class=post-title>Building Solid Kubernetes Controllers</h1><div class=post-meta><span title='2024-12-13 17:50:05 -0600 -0600'>December 13, 2024</span>&nbsp;·&nbsp;Tony</div></header><div class=post-content><p>In the last post, I explained the utility and purpose of Kubernetes Controllers. This post will explain how to build them, and how to think about designing them. We&rsquo;ll go into Controller patterns, anti-patterns, and sharp edges of the model that you&rsquo;re bound to run into.</p><h1 id=controller-runtime---use-it>controller-runtime - use it.<a hidden class=anchor aria-hidden=true href=#controller-runtime---use-it>#</a></h1><p>Or don&rsquo;t, I don&rsquo;t care. It&rsquo;ll probably help though.</p><p>You can absolutely build a controller from scratch using <code>client-go</code> (and sometimes that makes sense), but most of the time you should just get started with <a href=https://github.com/kubernetes-sigs/controller-runtime>controller-runtime</a>. It provides a batteries-included approach to handling <strong>typical</strong> Kubernetes controller patterns and gives you everything you need when it comes to things like leader election (you want HA, right?), metrics & events, caching, and even webhook setup and serving. When you just need to watch some resources and have your controller reconcile some state when the resource changes, <code>controller-runtime</code> is awesome.</p><p>If you need super fine-grained control over the watching behavior or caching (for perf or scaling reasons or otherwise), you&rsquo;ll probably find yourself poking too many holes through the Watch/Owns abstraction and should consider something a bit more bespoke.</p><p>Additionally, if you have extremely complex state machine transitions or want to take actions against different <em>kinds</em> of updates (create/delete/update) against your resources, the standard <code>.Reconcile(object)</code> approach that <code>controller-runtime</code> gives you may leave you fighting against the framework.</p><p>Here&rsquo;s an extremely simple example controller implementation from their <a href=https://github.com/kubernetes-sigs/controller-runtime/tree/main/examples/builtins>examples</a>:</p><pre tabindex=0><code>// reconcileReplicaSet reconciles ReplicaSets
type reconcileReplicaSet struct {
	// client can be used to retrieve objects from the APIServer.
	client client.Client
}

// Implement reconcile.Reconciler so the controller can reconcile objects
var _ reconcile.Reconciler = &amp;reconcileReplicaSet{}

func (r *reconcileReplicaSet) Reconcile(ctx context.Context, request reconcile.Request) (reconcile.Result, error) {
	// set up a convenient log object so we don&#39;t have to type request over and over again
	log := log.FromContext(ctx)

	// Fetch the ReplicaSet from the cache
	rs := &amp;appsv1.ReplicaSet{}
	err := r.client.Get(ctx, request.NamespacedName, rs)
	if errors.IsNotFound(err) {
		log.Error(nil, &#34;Could not find ReplicaSet&#34;)
		return reconcile.Result{}, nil
	}

	if err != nil {
		return reconcile.Result{}, fmt.Errorf(&#34;could not fetch ReplicaSet: %+v&#34;, err)
	}

	// Print the ReplicaSet
	log.Info(&#34;Reconciling ReplicaSet&#34;, &#34;container name&#34;, rs.Spec.Template.Spec.Containers[0].Name)

	// Set the label if it is missing
	if rs.Labels == nil {
		rs.Labels = map[string]string{}
	}
	if rs.Labels[&#34;hello&#34;] == &#34;world&#34; {
		return reconcile.Result{}, nil
	}

	// Update the ReplicaSet
	rs.Labels[&#34;hello&#34;] = &#34;world&#34;
	err = r.client.Update(ctx, rs)
	if err != nil {
		return reconcile.Result{}, fmt.Errorf(&#34;could not write ReplicaSet: %+v&#34;, err)
	}

	return reconcile.Result{}, nil
}
</code></pre><h2 id=read-the-sacred-texts>read the sacred texts<a hidden class=anchor aria-hidden=true href=#read-the-sacred-texts>#</a></h2><p>Before you dive into building your own controllers though, do yourself a favor and spend some quality time with the Kubebuilder book (<a href=https://book.kubebuilder.io/>https://book.kubebuilder.io/</a>). Understanding how Kubernetes expects APIs to behave will save you countless hours of headaches down the road.
It&rsquo;ll also set you up well for writing CRDs and generating their specs from go types.</p><p>Second, SIG Architecture has laid out some seriously well-thought-out conventions in their <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties>API guidelines</a>. I constantly find myself referring to these guidelines, especially for things like exposing meaningful statuses and conditions.
These aren&rsquo;t just suggestions - they&rsquo;re the difference between your controller playing nice with the ecosystem and it being that one weird implementation that makes everyone&rsquo;s lives harder. Take it from someone who&rsquo;s had to refactor controllers because they didn&rsquo;t align with these patterns: invest the time upfront to understand how status conditions should work, what fields belong in spec versus status, and how to structure your CRDs properly.</p><p>Following these conventions will make sure your controller behaves how users expect it to. While your controller can be &ldquo;technically correct&rdquo; or &ldquo;built to spec&rdquo;, it&rsquo;s a lot better of an experience for users when it has clear side effects, integrates well with existing tooling, and provides meaningful information about what its doing.</p><h2 id=level-triggered-vs-edge-triggered-design>level-triggered vs. edge-triggered design<a hidden class=anchor aria-hidden=true href=#level-triggered-vs-edge-triggered-design>#</a></h2><p>Let&rsquo;s talk about one of the most important design principles in Kubernetes controllers: level-triggered behavior. If you&rsquo;re coming from a background in systems programming, you might be familiar with these terms from event notification systems like <a href=https://en.wikipedia.org/wiki/Epoll>epoll</a>. If not, don&rsquo;t worry - I&rsquo;ll break it down.</p><p>Edge-triggered systems react to changes (the &ldquo;edges&rdquo; between states). Think of it like a motion sensor light - it only triggers when it detects movement. Level-triggered systems, on the other hand, continuously check the current state against the desired state. This is more like the thermostat example from the last blog (and k8s docs) that&rsquo;s constantly checking if the room temperature matches what you&rsquo;ve set.</p><p>Kubernetes controllers are designed to be level-triggered, and this is absolutely crucial. Here&rsquo;s why:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Edge-triggered (swat! bad, no!)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reconciler</span><span class=p>)</span> <span class=nf>Reconcile</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>req</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>(</span><span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>myResource</span> <span class=nx>myv1</span><span class=p>.</span><span class=nx>MyResource</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>req</span><span class=p>.</span><span class=nx>NamespacedName</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>myResource</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Only react to specific changes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>myResource</span><span class=p>.</span><span class=nx>Generation</span> <span class=o>!=</span> <span class=nx>myResource</span><span class=p>.</span><span class=nx>Status</span><span class=p>.</span><span class=nx>ObservedGeneration</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Handle the change
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=nx>r</span><span class=p>.</span><span class=nf>handleSpecChange</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>myResource</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Otherwise do nothing
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Level-triggered (yes... good, good)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reconciler</span><span class=p>)</span> <span class=nf>Reconcile</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>req</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>(</span><span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>myResource</span> <span class=nx>myv1</span><span class=p>.</span><span class=nx>MyResource</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>req</span><span class=p>.</span><span class=nx>NamespacedName</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>myResource</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Always check everything
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>current</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>gatherCurrentState</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>myResource</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>desired</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>calculateDesiredState</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>myResource</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Make any needed changes to align current with desired
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>r</span><span class=p>.</span><span class=nf>reconcileState</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>myResource</span><span class=p>,</span> <span class=nx>current</span><span class=p>,</span> <span class=nx>desired</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The edge-triggered approach might seem more efficient at first glance. Why do work if nothing&rsquo;s changed, right? But this thinking can lead to some nasty failure modes:</p><p>What if your controller crashes while processing a change? Without checking the full state each time, you might miss that the work wasn&rsquo;t completed.</p><p>What if an external agent (like an angry engineer just trying to get their thing to work with kubectl) modifies a resource your controller manages? If you&rsquo;re only watching for specific changes, you might miss these modifications entirely.</p><p>What if the Watch connection to the API server hiccups and you miss some events (more on this later)? With an edge-triggered approach, you&rsquo;re now out of sync and might not catch up.</p><p>A level-triggered approach means our controller is resilient to all sorts of failures - missed events, external changes, partial failures during reconciliation, you name it. Each reconciliation loop is a fresh chance to make things right.</p><p>The Watch API is still important - it&rsquo;s how we know when to check things quickly rather than waiting for our periodic reconciliation. But we never assume that the watch events tell us everything we need to know about what&rsquo;s changed. They&rsquo;re more like helpful hints about when to look, not authoritative statements about what&rsquo;s different.</p><p>This pattern of &ldquo;calculate desired state, check current state, fix differences&rdquo; is fundamental to how Kubernetes itself works. It&rsquo;s what makes the system so resilient to failures and so good at self-healing. When you&rsquo;re building your own controllers, embrace this pattern. Your future self (and your on-call rotation) will thank you.</p><h2 id=breaking-down-the-reconciliation-loop>breaking down the reconciliation loop<a hidden class=anchor aria-hidden=true href=#breaking-down-the-reconciliation-loop>#</a></h2><p>Now let&rsquo;s assume you&rsquo;ve taken my advice, are using <code>controller-runtime</code>, did the recommended reading, and understand level-triggered design. You&rsquo;ve gotten setup out of the way and now need to build your functionality into the controller.</p><p>As you saw above, with <code>controller-runtime</code> you&rsquo;re given an entrypoint in the <code>Reconcile</code> method. This is kicked off by the <a href=https://kubernetes.io/docs/reference/using-api/api-concepts/#efficient-detection-of-changes>Watch API</a>, which gives you a stream of events for resources you care about (you can do all objects of kind X, only those matching certain labels, up to you).
An important callout here is that you can&rsquo;t trust that you&rsquo;ll see every event. Watches can disconnect, events can be missed, and sometimes the API server may just kick your watch and restart it. This is what makes the reconciliation loop so important. You&rsquo;re not just handling events as they come in - you&rsquo;re responsible for ensuring the entire state is correct <strong>every time you reconcile the resource</strong>.</p><p>Here&rsquo;s how you should think about reconciliation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reconciler</span><span class=p>)</span> <span class=nf>Reconcile</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>req</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>(</span><span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span> <span class=o>:=</span> <span class=nx>log</span><span class=p>.</span><span class=nf>FromContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 1. Get your resource.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>myResource</span> <span class=nx>myv1</span><span class=p>.</span><span class=nx>MyResource</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>req</span><span class=p>.</span><span class=nx>NamespacedName</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>myResource</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>r</span><span class=p>.</span><span class=nf>handleGetError</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. Check if we&#39;re deleted/being deleted
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>!</span><span class=nx>myResource</span><span class=p>.</span><span class=nx>DeletionTimestamp</span><span class=p>.</span><span class=nf>IsZero</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	    <span class=k>if</span> <span class=nx>controllerutil</span><span class=p>.</span><span class=nf>ContainsFinalizer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>myResource</span><span class=p>,</span> <span class=nx>myFinalizerName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		    <span class=c1>// Run any necessary cleanup logic.
</span></span></span><span class=line><span class=cl><span class=c1></span>		    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>cleanupExternalResources</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>myResource</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			    <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;cleanup failed: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		    <span class=p>}</span>
</span></span><span class=line><span class=cl>	    <span class=p>}</span>
</span></span><span class=line><span class=cl>	    <span class=c1>// Remove our finalizer to allow deletion to continue.
</span></span></span><span class=line><span class=cl><span class=c1></span>	    <span class=nx>controllerutil</span><span class=p>.</span><span class=nf>RemoveFinalizer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>myResource</span><span class=p>,</span> <span class=nx>myFinalizerName</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Update</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>myResource</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		    <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;finalizer removal failed: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	    <span class=p>}</span>
</span></span><span class=line><span class=cl>	    <span class=c1>// Thing&#39;s been deleted, nothing to do.
</span></span></span><span class=line><span class=cl><span class=c1></span>	    <span class=c1>// (Or you can add additional logic here)
</span></span></span><span class=line><span class=cl><span class=c1></span>	    <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 3. Ensure our finalizer is present for active resources.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>ensureFinalizer</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>myResource</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;ensuring finalizer failed: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 4. Validate current state.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>validateResource</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>myResource</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>r</span><span class=p>.</span><span class=nf>handleValidationError</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>myResource</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 5. Check dependent resources if your resource manages other resources.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>dependentResources</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>gatherDependentResources</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>myResource</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;gathering dependent resources failed: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 6. Determine what needs to change.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>changes</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>determineRequiredChanges</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>myResource</span><span class=p>,</span> <span class=nx>dependentResources</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 7. Apply changes.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>applyChanges</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>myResource</span><span class=p>,</span> <span class=nx>changes</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>r</span><span class=p>.</span><span class=nf>handleChangeError</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 8. Update status.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>updateStatus</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>myResource</span><span class=p>,</span> <span class=nx>dependentResources</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;updating status failed: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 9. Schedule next reconciliation if needed.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>r</span><span class=p>.</span><span class=nf>determineNextReconcile</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>myResource</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>There&rsquo;s a lot to unpack here, let&rsquo;s go through it.</p><h3 id=resource-ownership>resource ownership<a hidden class=anchor aria-hidden=true href=#resource-ownership>#</a></h3><p>One of the most fundamental patterns in Kubernetes controllers is resource <a href=https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/>ownership</a>. When your controller creates resources on behalf of your custom resource (like ConfigMaps, Secrets, or even Pods), you need to establish proper ownership relationships. This isn&rsquo;t just about being organized - it&rsquo;s about enabling Kubernetes&rsquo; garbage collection to work properly.</p><p>If your resource creates ConfigMaps for example, you&rsquo;ll end up setting ControllerReferences:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reconciler</span><span class=p>)</span> <span class=nf>createConfigMap</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>owner</span> <span class=o>*</span><span class=nx>myv1</span><span class=p>.</span><span class=nx>MyResource</span><span class=p>,</span> <span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>data</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>configMap</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>corev1</span><span class=p>.</span><span class=nx>ConfigMap</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>ObjectMeta</span><span class=p>:</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>ObjectMeta</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>Name</span><span class=p>:</span>      <span class=nx>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>Namespace</span><span class=p>:</span> <span class=nx>owner</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=nx>Data</span><span class=p>:</span> <span class=nx>data</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// This is crucial - it sets up the owner reference.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>controllerutil</span><span class=p>.</span><span class=nf>SetControllerReference</span><span class=p>(</span><span class=nx>owner</span><span class=p>,</span> <span class=nx>configMap</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>scheme</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;setting controller reference: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Create with a retry in case of conflicts.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>retry</span><span class=p>.</span><span class=nf>RetryOnConflict</span><span class=p>(</span><span class=nx>retry</span><span class=p>.</span><span class=nx>DefaultRetry</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>configMap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>apierrors</span><span class=p>.</span><span class=nf>IsAlreadyExists</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now you&rsquo;ve set up a relationship where <code>MyResource --owns--> ConfigMap</code>.
Make sure you&rsquo;re thinking through what could happen with the lifecycle of these resources:</p><ol><li>What happens if a child resource is manually deleted? If you expect it to always be there you may introduce a panic.</li><li>What order should resources be created in? This was important when I worked on something that replicated Helm.</li><li>How do you handle partial creation scenarios? If some of your resources get created but others fail, do you have to tear-down and retry?</li></ol><p>When managing dependent resources, you should consider collecting failures and surfacing them as reconciliation failures via your owner resources&rsquo; Conditions so downstream users can see the failures. Logs may be great for you, but Kubernetes Events and Conditions are great for you AND your users :)</p><p>That brings me to my next point.</p><h3 id=state-tracking-and-status-updates>state tracking and status updates<a hidden class=anchor aria-hidden=true href=#state-tracking-and-status-updates>#</a></h3><p>Status updates are how your controller communicates with the outside world. They&rsquo;re not just about setting a &ldquo;Ready&rdquo; condition - they&rsquo;re about providing meaningful information about the state of your resource and its dependencies.
<em>Note: PLEASE take the advice of the api-guidelines from the SIG and DO NOT EXPOSE YOUR NOTION OF AN FSM though an Enum. It&rsquo;s oftentimes more confusing than it is helpful.</em></p><p>For an example Resource that manages the deployment of a workload, consider condition Types like the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Better condition types that follow API conventions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ConditionTypeResourcesAvailable indicates whether all required dependent resources 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// exist and are functioning correctly.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ConditionTypeResourcesAvailable</span> <span class=kt>string</span> <span class=p>=</span> <span class=s>&#34;ResourcesAvailable&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// ConditionTypeConfigurationReady indicates whether the resource&#39;s configuration has been 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// applied successfully.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ConditionTypeConfigurationReady</span> <span class=kt>string</span> <span class=p>=</span> <span class=s>&#34;ConfigurationReady&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// ConditionTypeWorkloadHealthy indicates whether the managed workload is operating within
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// expected parameters
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ConditionTypeWorkloadHealthy</span> <span class=kt>string</span> <span class=p>=</span> <span class=s>&#34;WorkloadHealthy&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// ConditionTypeReady summarizes the overall operational status of the resource.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ConditionTypeReady</span> <span class=kt>string</span> <span class=p>=</span> <span class=s>&#34;Ready&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>With these conditions (combined with explanatory reasons + messages), users would be well-informed of the status of dependent resources, the workload, and the manager object itself.
The condition types have observable states, clear polarity, and include a summary condition that attempts provides a good rollup of any failures.</p><h3 id=resource-version-handling---conflict-resolution>resource version handling - conflict resolution<a hidden class=anchor aria-hidden=true href=#resource-version-handling---conflict-resolution>#</a></h3><p>Every Kubernetes object has a <a href=https://kubernetes.io/docs/reference/using-api/api-concepts/#efficient-detection-of-changes>resource version</a>, and it changes every time the object is modified. This is crucial for implementing optimistic concurrency control. When you update a resource, make sure you pull the latest version of the resource and apply your changes WITHIN the <code>retry.RetryOnConflict</code> function.</p><p>Here&rsquo;s an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reconciler</span><span class=p>)</span> <span class=nf>updateResource</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>resource</span> <span class=o>*</span><span class=nx>myv1</span><span class=p>.</span><span class=nx>MyResource</span><span class=p>,</span> <span class=nx>update</span> <span class=kd>func</span><span class=p>(</span><span class=o>*</span><span class=nx>myv1</span><span class=p>.</span><span class=nx>MyResource</span><span class=p>))</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>retry</span><span class=p>.</span><span class=nf>RetryOnConflict</span><span class=p>(</span><span class=nx>retry</span><span class=p>.</span><span class=nx>DefaultRetry</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Get the latest version.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fresh</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>myv1</span><span class=p>.</span><span class=nx>MyResource</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>client</span><span class=p>.</span><span class=nf>ObjectKeyFromObject</span><span class=p>(</span><span class=nx>resource</span><span class=p>),</span> <span class=nx>fresh</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;getting fresh resource failed: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Apply our changes to the fresh copy.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>update</span><span class=p>(</span><span class=nx>fresh</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Try to update.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Update</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>fresh</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Update our local copy if needed.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>*</span><span class=nx>resource</span> <span class=p>=</span> <span class=o>*</span><span class=nx>fresh</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=finalizers---wake-me-up-before-you-go-go>finalizers - wake me up before you go go<a hidden class=anchor aria-hidden=true href=#finalizers---wake-me-up-before-you-go-go>#</a></h3><p>Finalizers are one of those Kubernetes features that seem simple at first glance but have some fascinating complexity under the hood. They&rsquo;re like the close door button in an elevator - they don&rsquo;t make the deletion happen faster, but they ensure it happens safely.</p><p>When you add a finalizer to a resource, you&rsquo;re essentially telling Kubernetes &ldquo;hold up, don&rsquo;t delete this yet - I need to clean some things up first.&rdquo; This is crucial when your controller manages resources that exist outside the Kubernetes cluster (like cloud resources) or when you need to ensure proper cleanup of dependent resources.</p><p>Here&rsquo;s how the deletion process actually works:</p><ol><li>A user or system requests deletion of a resource</li><li>Kubernetes checks for finalizers</li><li>If finalizers exist:<ul><li>Sets deletion timestamp</li><li>Keeps resource around in &ldquo;terminating&rdquo; state</li></ul></li><li>Controllers see deletion timestamp, perform cleanup</li><li>Controllers remove their finalizers</li><li>Once all finalizers are gone, Kubernetes deletes the resource</li></ol><p>(If you&rsquo;ve ever tried to delete a namespace and it gets stuck, you&rsquo;re <em>probably</em> running into a finalizer issue)</p><p>Let&rsquo;s look at a sample finalizer implementation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=nx>finalizerName</span> <span class=p>=</span> <span class=s>&#34;awesomecontroller.tdoot.com/cleanup&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reconciler</span><span class=p>)</span> <span class=nf>ensureFinalizer</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>resource</span> <span class=o>*</span><span class=nx>myv1</span><span class=p>.</span><span class=nx>MyResource</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>controllerutil</span><span class=p>.</span><span class=nf>ContainsFinalizer</span><span class=p>(</span><span class=nx>resource</span><span class=p>,</span> <span class=nx>finalizerName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>controllerutil</span><span class=p>.</span><span class=nf>AddFinalizer</span><span class=p>(</span><span class=nx>resource</span><span class=p>,</span> <span class=nx>finalizerName</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>r</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Update</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>resource</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reconciler</span><span class=p>)</span> <span class=nf>handleDeletion</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>resource</span> <span class=o>*</span><span class=nx>myv1</span><span class=p>.</span><span class=nx>MyResource</span><span class=p>)</span> <span class=p>(</span><span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>controllerutil</span><span class=p>.</span><span class=nf>ContainsFinalizer</span><span class=p>(</span><span class=nx>resource</span><span class=p>,</span> <span class=nx>finalizerName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Clean up external resources.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>cleanupExternalResources</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>resource</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// If cleanup fails, we keep the finalizer and retry
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{</span><span class=nx>RequeueAfter</span><span class=p>:</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Minute</span><span class=p>},</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;cleanup failed: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Remove our finalizer.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>controllerutil</span><span class=p>.</span><span class=nf>RemoveFinalizer</span><span class=p>(</span><span class=nx>resource</span><span class=p>,</span> <span class=nx>finalizerName</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Update</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>resource</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;removing finalizer failed: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=rate-limiting---cool-off>rate limiting - cool off<a hidden class=anchor aria-hidden=true href=#rate-limiting---cool-off>#</a></h3><p>Rate limiting in controllers is more complex than just adding some simple delays. We need to handle multiple types of rate limiting:</p><ol><li>Workqueue rate limiting for individual resources</li><li>Overall controller throughput</li><li>API server request limiting</li><li>External API rate limiting</li></ol><p>Number 3 brings up a not-so-fond memory of working with a very popular CD tool with a less mature Kubernetes API gateway. It generated so many requests against the API server that we&rsquo;d effectively lock ourselves out of deploying anything when we hit rate limits. Our deployments would break and because of the rate limits we couldn&rsquo;t even fix them.</p><p>When you look to implement rate-limiting in your controller, check out <code>workqueue.RateLimiter</code> from the <code>client-go</code> package.
<a href=https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go#L171>Here&rsquo;s </a>an example in their codebase.</p><h3 id=deep-copy---dont-double-dip-the-chip>deep copy - don&rsquo;t double dip the chip<a hidden class=anchor aria-hidden=true href=#deep-copy---dont-double-dip-the-chip>#</a></h3><p>Deep copying in controllers is about more than just avoiding mutations - it&rsquo;s about handling concurrent access to objects correctly. The client-go cache is shared across all controllers, so we need to be extremely careful about modifications.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reconciler</span><span class=p>)</span> <span class=nf>Reconcile</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>req</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>(</span><span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Get from API server
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>original</span> <span class=nx>myv1</span><span class=p>.</span><span class=nx>MyResource</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>req</span><span class=p>.</span><span class=nx>NamespacedName</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>original</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>reconcile</span><span class=p>.</span><span class=nx>Result</span><span class=p>{},</span> <span class=nx>client</span><span class=p>.</span><span class=nf>IgnoreNotFound</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// ALWAYS work with a copy for modifications.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>resource</span> <span class=o>:=</span> <span class=nx>original</span><span class=p>.</span><span class=nf>DeepCopy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=c1>// Do whatever ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// Fetch a fresh copy when you try to apply.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>retry</span><span class=p>.</span><span class=nf>RetryOnConflict</span><span class=p>(</span><span class=nx>retry</span><span class=p>.</span><span class=nx>DefaultRetry</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Get latest version
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>var</span> <span class=nx>latest</span> <span class=nx>myv1</span><span class=p>.</span><span class=nx>MyResource</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>req</span><span class=p>.</span><span class=nx>NamespacedName</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>latest</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Apply our changes to the fresh copy
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>latest</span><span class=p>.</span><span class=nx>Spec</span> <span class=p>=</span> <span class=nx>resource</span><span class=p>.</span><span class=nx>Spec</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Try to update
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=nx>r</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Update</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>latest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This attention to copying isn&rsquo;t just about correctness - it&rsquo;s about preventing subtle bugs that only show up under load or in production environments. The extra allocations from copying are almost always worth it compared to the cost of debugging race conditions or cache corruption.</p><h2 id=wrapping-it-all-up---build-with-the-pager-in-mind>wrapping it all up - build with the pager in mind<a hidden class=anchor aria-hidden=true href=#wrapping-it-all-up---build-with-the-pager-in-mind>#</a></h2><p>A properly built controller needs to be resilient to network issues, API server restarts, and engineers who use <code>kubectl edit</code> where they shouldn&rsquo;t.</p><p>For your own sake, remember to:</p><ul><li>Always think level-triggered, not edge-triggered. Your controller should be able to jump in at any point and figure out what needs to be done.</li><li>Treat the API server&rsquo;s watch events as helpful hints, not as the single source of truth. Always verify the current state before making changes.</li><li>Use finalizers religiously, but make sure to not hang! They&rsquo;re your safety net for cleaning up resources, especially anything outside the cluster.</li><li>Handle rate limiting at multiple levels. Your controller isn&rsquo;t the only thing running in the cluster, so play nice with others.</li><li>Copy objects like your production stability depends on it (because it does).</li><li>Status conditions aren&rsquo;t just for show - they&rsquo;re how your controller communicates with the rest of the world.</li></ul><p>Most importantly, remember that controllers are part of the control plane of your cluster. They need to be more reliable than the workloads they&rsquo;re managing. Every panic is a potential outage, every race condition is a ticking time bomb, and every unhandled edge case is a future incident waiting to happen.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tdoot.com/tags/kubernetes/>kubernetes</a></li></ul><nav class=paginav><a class=next href=https://tdoot.com/blog/kubernetes-controllers-explained/><span class=title>Next »</span><br><span>kubernetes controllers explained - how your cluster stays in line</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Building Solid Kubernetes Controllers on twitter" href="https://twitter.com/intent/tweet/?text=Building%20Solid%20Kubernetes%20Controllers&url=https%3a%2f%2ftdoot.com%2fblog%2fbuilding-solid-kubernetes-controllers%2f&hashtags=kubernetes"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Building Solid Kubernetes Controllers on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2ftdoot.com%2fblog%2fbuilding-solid-kubernetes-controllers%2f&title=Building%20Solid%20Kubernetes%20Controllers&summary=Building%20Solid%20Kubernetes%20Controllers&source=https%3a%2f%2ftdoot.com%2fblog%2fbuilding-solid-kubernetes-controllers%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Building Solid Kubernetes Controllers on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ftdoot.com%2fblog%2fbuilding-solid-kubernetes-controllers%2f&title=Building%20Solid%20Kubernetes%20Controllers"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Building Solid Kubernetes Controllers on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftdoot.com%2fblog%2fbuilding-solid-kubernetes-controllers%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Building Solid Kubernetes Controllers on whatsapp" href="https://api.whatsapp.com/send?text=Building%20Solid%20Kubernetes%20Controllers%20-%20https%3a%2f%2ftdoot.com%2fblog%2fbuilding-solid-kubernetes-controllers%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Building Solid Kubernetes Controllers on telegram" href="https://telegram.me/share/url?text=Building%20Solid%20Kubernetes%20Controllers&url=https%3a%2f%2ftdoot.com%2fblog%2fbuilding-solid-kubernetes-controllers%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://tdoot.com/>tdoot's odd little bazaar</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>